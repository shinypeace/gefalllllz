<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Тайна рун</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=Lobster&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <style>
        :root {
            /* Базовая палитра */
            --bg-main: #1a1a2e;
            --bg-secondary: rgba(22, 33, 62, 0.9);
            --bg-modal: rgba(15, 23, 42, 0.98);
            --text-primary: #ff2e63;
            --text-secondary: #e0e6ed;
            --accent-color: #08d9d6;
            --border-color: #ff2e63;
            --font-main: 'Inter', sans-serif;
            --font-title: 'Lobster', cursive;
            --progress-bar-bg: #16213e;
            --progress-bar-fill: #ff2e63;
        }

        /* ТЕМЫ */
        .theme-space .main-container { background-image: url('bg-space.png'); }
        .theme-forest .main-container { background-image: url('bg-forest.png'); }
        .theme-ocean .main-container { background-image: url('bg-ocean.png'); }
        .theme-retro .main-container { background-image: url('bg-retro.png'); }

        .theme-forest {
            --bg-main: #1b3a1b; --text-primary: #ffd700; --accent-color: #4caf50; --border-color: #ffd700;
        }
        .theme-ocean {
            --bg-main: #001f3f; --text-primary: #00ffff; --accent-color: #0074d9; --border-color: #00ffff;
        }
        .theme-retro {
            --bg-main: #111; --text-primary: #39ff14; --accent-color: #bd00ff; --border-color: #39ff14;
        }

        /* ОБЩИЕ СТИЛИ */
        body {
            font-family: var(--font-main); 
            background-color: var(--bg-main); 
            color: var(--text-secondary);
            touch-action: none; overflow: hidden; height: 100vh; margin: 0;
            user-select: none; -webkit-user-select: none;
        }

        #preloader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-main);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; transition: opacity 0.5s ease;
        }
        #loading-bar-container {
            width: 70%; max-width: 300px; height: 10px; background: rgba(255,255,255,0.1);
            border-radius: 5px; overflow: hidden; margin-top: 20px;
        }
        #loading-bar-fill {
            width: 0%; height: 100%; background-color: var(--text-primary); transition: width 0.3s;
        }

        .main-container {
            display: none; justify-content: center; align-items: center;
            height: 100%; width: 100%; overflow: hidden;
            background-size: cover; background-position: center;
        }

        /* МЕНЮ И ЭКРАНЫ */
        .main-menu, .game-screen {
            width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding: 1rem; box-sizing: border-box; position: relative;
        }

        .main-menu { justify-content: center; gap: 1rem; }
        .game-screen { justify-content: flex-start; }

        .game-title {
            font-family: var(--font-title); font-size: 4rem; line-height: 1.1;
            color: var(--text-primary); text-align: center; margin-bottom: 2rem;
            text-shadow: 3px 3px 0 var(--accent-color), 0 0 20px rgba(0,0,0,0.5);
        }

        /* КНОПКИ МЕНЮ */
        .btn-menu {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--border-color); border-radius: 12px;
            color: #fff; font-size: 1.4rem; font-weight: 800;
            padding: 1rem; width: 80%; max-width: 300px;
            cursor: pointer; transition: transform 0.1s, background 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
            backdrop-filter: blur(5px);
            margin-bottom: 0.8rem;
        }
        .btn-menu:active { transform: scale(0.96); background: rgba(255,255,255,0.1); }

        /* РЯД КНОПОК (НАСТРОЙКИ, ПРАВИЛА, СТАТИСТИКА) */
        .menu-icons-row {
            display: flex; justify-content: center; gap: 1rem;
            width: 80%; max-width: 300px; margin-top: 0.5rem;
        }
        .icon-btn-square {
            width: 60px; height: 60px;
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: transform 0.1s;
            backdrop-filter: blur(5px);
        }
        .icon-btn-square:active { transform: scale(0.9); }
        .icon-btn-square svg { width: 32px; height: 32px; fill: var(--text-secondary); }

        /* ИГРОВОЙ ИНТЕРФЕЙС */
        .game-header {
            width: 100%; display: flex; flex-wrap: wrap; gap: 0.5rem;
            margin-bottom: 0.5rem; padding: 0.5rem;
            background: var(--bg-secondary); border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .header-item {
            display: flex; align-items: center; justify-content: center;
            padding: 0.5rem; background: rgba(0,0,0,0.3);
            border-radius: 0.5rem; flex-grow: 1; font-weight: 700;
        }
        #rise-progress-bar-container {
            width: 100%; height: 6px; background: rgba(0,0,0,0.3);
            border-radius: 3px; overflow: hidden; margin-top: 4px;
        }
        #rise-progress-bar {
            width: 0%; height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--text-primary));
            transition: width 0.3s ease;
        }

        /* ИГРОВОЕ ПОЛЕ */
        #game-board {
            position: relative; 
            /* Width calculation handles in JS for responsiveness */
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 1rem;
            margin: 0 auto;
            /* Важно для предотвращения выхода за границы */
            overflow: hidden; 
        }

        .tile {
            position: absolute; 
            display: flex; justify-content: center; align-items: center;
            will-change: top, left, transform;
            /* Z-index 10 для гемов, чтобы они были над фоном, но под модалками */
            z-index: 10; 
        }
        
        /* Блоки камней должны быть ниже гемов при анимации падения, 
           но так как гемы не должны "залетать" за них, мы используем логику.
           Однако, если они наслаиваются, можно поднять z-index у блоков, 
           но тогда гемы будут падать "за" ними, что тоже странно.
           Правильнее: Гемы не должны быть в той же ячейке. */
           
        .tile.unmovable { z-index: 5; } /* Статичные блоки */

        .tile-inner {
            width: 94%; height: 94%;
            background-size: contain; background-repeat: no-repeat; background-position: center;
            /* СТАТИЧНЫЕ ГЕМЫ - НИКАКОЙ АНИМАЦИИ FLOAT */
        }

        /* Ассеты */
        .gem-red { background-image: url('gem-red.png'); }
        .gem-blue { background-image: url('gem-blue.png'); }
        .gem-green { background-image: url('gem-green.png'); }
        .gem-yellow { background-image: url('gem-yellow.png'); }
        .gem-purple { background-image: url('gem-purple.png'); }
        .gem-orange { background-image: url('gem-orange.png'); }
        
        /* Бонусы пульсируют */
        .bomb { background-image: url('bonus-bomb.png') !important; animation: pulse 1s infinite alternate; }
        .rocket { background-image: url('bonus-rocket.png') !important; animation: pulse 1s infinite alternate; }
        .unmovable .tile-inner { background-image: url('block-stone.png') !important; animation: none; }
        
        @keyframes pulse { from { transform: scale(0.95); } to { transform: scale(1.1); } }

        /* Анимации действий */
        .tile.match .tile-inner { animation: matchPop 0.3s forwards; }
        @keyframes matchPop { 0% { transform: scale(1); } 50% { transform: scale(1.2); filter: brightness(2); } 100% { transform: scale(0); opacity: 0; } }

        .tile.shake .tile-inner { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        /* Модальные окна */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-modal); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; visibility: hidden; transition: 0.3s;
        }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content {
            background: #1f2937; padding: 2rem; border-radius: 1.5rem;
            border: 2px solid var(--accent-color); width: 90%; max-width: 350px; text-align: center;
        }
        
        /* Свитчи (Ползунки) */
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        /* Зеленый когда включено (checked) */
        input:checked + .slider { background-color: var(--text-primary); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Эффекты */
        .rocket-effect { position: absolute; background: white; opacity: 0.8; z-index: 20; border-radius: 10px; pointer-events: none; }
    </style>
</head>
<body class="theme-space">
    <!-- PRELOADER -->
    <div id="preloader">
        <h1 class="game-title" style="font-size: 3rem;">Тайна рун</h1>
        <div id="loading-bar-container"><div id="loading-bar-fill"></div></div>
        <div id="loading-status" style="margin-top: 10px;">Загрузка...</div>
    </div>

    <!-- MUSIC -->
    <audio id="bg-music" src="music.mp3" loop preload="auto"></audio>

    <div class="main-container">
        <!-- MAIN MENU -->
        <div id="main-menu-screen" class="main-menu">
            <div></div> <!-- Spacer top -->
            
            <div style="width: 100%; display: flex; flex-direction: column; align-items: center;">
                <h1 class="game-title">Тайна рун</h1>
                
                <button id="classic-mode-btn" class="btn-menu">Классика</button>
                <button id="hard-mode-btn" class="btn-menu" style="border-color: #ff4757; color: #ff4757;">Хард</button>
                
                <!-- NEW BUTTONS LAYOUT -->
                <div class="menu-icons-row">
                    <button id="settings-btn" class="icon-btn-square" aria-label="Настройки">
                        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84a.484.484 0 0 0-.48.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.04.17 0 .36.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.27.41.48.41h3.84c.24 0 .44-.17.48-.41l.36-2.54c.59-.24 1.13-.57 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.04-.22 0-.45-.12-.61l-2.03-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                    </button>
                    <button id="rules-btn" class="icon-btn-square" aria-label="Правила">
                        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
                    </button>
                    <button id="stats-btn" class="icon-btn-square" aria-label="Статистика">
                        <svg viewBox="0 0 24 24"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>
                    </button>
                </div>
            </div>

            <div></div> <!-- Spacer bottom -->
        </div>

        <!-- GAME SCREEN -->
        <div id="game-screen" class="game-screen hidden">
            <div class="game-header">
                <div class="header-item" style="flex: 2; justify-content: flex-start;">
                    <span style="margin-right: 5px;">⭐</span> <span id="score">0</span>
                </div>
                <div class="header-item" style="flex: 0;">
                    <button id="pause-btn" style="background: none; border: none; font-size: 1.5rem;">⏸️</button>
                </div>
                <div class="header-item">
                    <span>Ход: <span id="moves-count">0</span></span>
                </div>
                <div id="rise-progress-bar-container"><div id="rise-progress-bar"></div></div>
            </div>

            <div id="game-board"></div>
        </div>
    </div>

    <!-- MODALS -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-white">Настройки</h2>
            
            <div class="flex justify-between items-center w-full mb-4 px-2">
                <span class="text-lg text-white">Звуки</span>
                <label class="switch">
                    <input type="checkbox" id="mute-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="flex justify-between items-center w-full mb-6 px-2">
                <span class="text-lg text-white">Музыка</span>
                <label class="switch">
                    <input type="checkbox" id="mute-music-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="grid grid-cols-4 gap-2 mb-6">
                <button class="theme-btn w-10 h-10 rounded-full border-2" style="background:#1a1a2e" data-theme="theme-space"></button>
                <button class="theme-btn w-10 h-10 rounded-full border-2" style="background:#1b3a1b" data-theme="theme-forest"></button>
                <button class="theme-btn w-10 h-10 rounded-full border-2" style="background:#001f3f" data-theme="theme-ocean"></button>
                <button class="theme-btn w-10 h-10 rounded-full border-2" style="background:#111" data-theme="theme-retro"></button>
            </div>

            <button id="close-settings-btn" class="btn-menu" style="width:100%">Закрыть</button>
        </div>
    </div>

    <div id="pause-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-white">Пауза</h2>
            <button id="resume-btn" class="btn-menu" style="width:100%">Продолжить</button>
            <button id="restart-game-btn" class="btn-menu" style="width:100%">Заново</button>
            <button id="main-menu-btn-pause" class="btn-menu" style="width:100%; border:1px solid #666; background:transparent;">Меню</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-2 text-white">Игра Окончена</h2>
            <p class="mb-4 text-gray-300">Счет: <span id="final-score" class="text-yellow-400 font-bold">0</span></p>
            <button id="restart-over-btn" class="btn-menu" style="width:100%">Играть снова</button>
            <button id="menu-over-btn" class="btn-menu" style="width:100%; border:1px solid #666; background:transparent;">Меню</button>
        </div>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content text-left">
            <h2 class="text-2xl font-bold mb-4 text-center text-white">Правила</h2>
            <ul class="text-gray-300 list-disc pl-5 space-y-2 text-sm">
                <li>Собирай 3+ одинаковых камня.</li>
                <li>Каждый N ход поле поднимается!</li>
                <li><strong>4 в ряд</strong> = Бомба (взрыв 3x3).</li>
                <li><strong>5 в ряд</strong> = Ракета (чистит линии).</li>
                <li>Не дай камням коснуться верха!</li>
            </ul>
            <button id="close-rules-btn" class="btn-menu mt-6" style="width:100%">Понятно</button>
        </div>
    </div>
    
    <div id="stats-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-white">Рекорды</h2>
            <div id="stats-content" class="text-white"></div>
            <button id="close-stats-btn" class="btn-menu mt-6" style="width:100%">Закрыть</button>
        </div>
    </div>

    <div id="vk_ads_banner" style="position:fixed; bottom:0; width:100%; z-index:1001;"></div>

    <script>
    // --- GLOBAL VARS ---
    const vkBridge = window.vkBridge;
    const ASSET_LIST = [
        'bg-space.png', 'bg-forest.png', 'bg-ocean.png', 'bg-retro.png',
        'gem-red.png', 'gem-blue.png', 'gem-green.png', 'gem-yellow.png', 'gem-purple.png', 'gem-orange.png',
        'bonus-bomb.png', 'bonus-rocket.png', 'block-stone.png'
    ];
    
    // Settings
    let isSoundOn = true; // Inverted logic: true = sound active
    let isMusicOn = true;
    let currentTheme = 'theme-space';
    let stats = { classic: { score:0 }, hard: { score:0 } };
    
    // Audio
    let audioReady = false;
    let synths = {};
    let musicPlayer = null;

    // Game State
    let board = [];
    const ROWS = 10;
    const COLS = 7;
    const GAP = 2; // Reduced gap
    let TILE_SIZE = 0;
    let score = 0;
    let movesCount = 0;
    let totalMoves = 0;
    let gameMode = 'classic';
    let isPaused = false;
    let isProcessing = false;
    
    // Input
    let dragStart = null;
    let lastTapTime = 0;

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', async () => {
        initVK();
        await loadAssets();
    });

    async function initVK() {
        if(vkBridge) {
            try {
                await vkBridge.send('VKWebAppInit');
                const user = await vkBridge.send('VKWebAppGetUserInfo').catch(() => null);
                loadData(user ? user.id : 'local');
            } catch(e) { console.log('VK Init fail', e); loadData('local'); }
        } else {
            loadData('local');
        }
    }

    async function loadAssets() {
        let loaded = 0;
        const total = ASSET_LIST.length;
        const bar = document.getElementById('loading-bar-fill');
        
        if(total === 0) { finishedLoading(); return; }

        ASSET_LIST.forEach(src => {
            const img = new Image();
            img.src = src;
            img.onload = () => { loaded++; updateBar(); };
            img.onerror = () => { loaded++; updateBar(); };
        });

        function updateBar() {
            bar.style.width = (loaded/total * 100) + '%';
            if(loaded === total) setTimeout(finishedLoading, 500);
        }
    }

    function finishedLoading() {
        document.getElementById('preloader').style.display = 'none';
        document.querySelector('.main-container').style.display = 'flex';
        updateThemeUI();
    }

    // --- DATA ---
    function loadData(userId) {
        const key = 'runes_save_' + userId;
        const raw = localStorage.getItem(key);
        if(raw) {
            const data = JSON.parse(raw);
            isSoundOn = data.sound !== undefined ? data.sound : true;
            isMusicOn = data.music !== undefined ? data.music : true;
            currentTheme = data.theme || 'theme-space';
            stats = data.stats || { classic: {score:0}, hard: {score:0} };
        }
        updateSettingsUI();
        applyTheme(currentTheme);
    }

    function saveData() {
        const data = { sound: isSoundOn, music: isMusicOn, theme: currentTheme, stats: stats };
        localStorage.setItem('runes_save_' + (window.vkUserId || 'local'), JSON.stringify(data));
    }

    // --- AUDIO ---
    async function initAudio() {
        if(audioReady) return;
        await Tone.start();
        
        const reverb = new Tone.Reverb(0.5).toDestination();
        synths = {
            tap: new Tone.Synth().connect(reverb),
            match: new Tone.PolySynth(Tone.Synth).connect(reverb),
            bonus: new Tone.NoiseSynth({ envelope: { decay: 0.5 } }).connect(reverb),
            lose: new Tone.Synth({ oscillator: { type: 'sawtooth' } }).toDestination()
        };
        synths.tap.volume.value = -10;
        synths.bonus.volume.value = -10;
        
        musicPlayer = new Tone.Player({ url: 'music.mp3', loop: true, volume: -15 }).toDestination();
        
        audioReady = true;
        if(isMusicOn) playMusic();
    }

    function playSound(name) {
        if(!isSoundOn || !audioReady) return;
        try {
            if(name === 'tap') synths.tap.triggerAttackRelease('C5', '32n');
            if(name === 'match') synths.match.triggerAttackRelease(['E5', 'G5'], '16n');
            if(name === 'bonus') synths.bonus.triggerAttackRelease('8n');
            if(name === 'lose') synths.lose.triggerAttackRelease('A2', '1n');
        } catch(e) {}
    }

    function playMusic() {
        if(isMusicOn && audioReady && musicPlayer && musicPlayer.state !== 'started') musicPlayer.start();
    }
    function stopMusic() {
        if(musicPlayer && musicPlayer.state === 'started') musicPlayer.stop();
    }

    document.body.addEventListener('click', initAudio, { once: true });

    // --- GAME LOGIC ---
    function startGame(mode) {
        gameMode = mode;
        score = 0; movesCount = 0; totalMoves = 0;
        isPaused = false; isProcessing = false;
        
        document.getElementById('main-menu-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
        
        updateUI();
        initBoard();
    }

    function initBoard() {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        board = [];
        
        // Calculate Size (Wider Logic)
        const containerW = Math.min(window.innerWidth * 0.95, 500); // 95% width, max 500px
        const containerH = window.innerHeight * 0.75; // 75% height
        
        // Try width-based first
        TILE_SIZE = Math.floor((containerW - (COLS + 1) * GAP) / COLS);
        // Check height constraint
        const totalH = (TILE_SIZE + GAP) * ROWS + GAP;
        if(totalH > containerH) {
            TILE_SIZE = Math.floor((containerH - (ROWS + 1) * GAP) / ROWS);
        }
        
        boardEl.style.width = `${(TILE_SIZE + GAP) * COLS + GAP}px`;
        boardEl.style.height = `${(TILE_SIZE + GAP) * ROWS + GAP}px`;

        // Fill Data
        for(let r=0; r<ROWS; r++) {
            board[r] = [];
            for(let c=0; c<COLS; c++) {
                if(r === ROWS-1) createTile(r, c, 'unmovable');
                else createTile(r, c, 'gem', getRandomColor());
            }
        }
        
        // Clear initial matches
        resolveMatches(true);
    }

    function createTile(r, c, type, subtype=null) {
        const div = document.createElement('div');
        div.className = `tile ${type}`;
        div.style.width = `${TILE_SIZE}px`;
        div.style.height = `${TILE_SIZE}px`;
        
        const inner = document.createElement('div');
        inner.className = 'tile-inner';
        if(subtype) inner.classList.add(subtype);
        div.appendChild(inner);

        const tile = { r, c, type, subtype, el: div, id: Math.random() };
        board[r][c] = tile;
        
        document.getElementById('game-board').appendChild(div);
        updateTilePos(tile, true);
        
        return tile;
    }

    function updateTilePos(tile, instant=false) {
        if(!tile) return;
        const x = GAP + tile.c * (TILE_SIZE + GAP);
        const y = GAP + tile.r * (TILE_SIZE + GAP);
        
        if(instant) {
            tile.el.style.transition = 'none';
            tile.el.style.left = x + 'px';
            tile.el.style.top = y + 'px';
        } else {
            tile.el.style.transition = 'top 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), left 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
            tile.el.style.left = x + 'px';
            tile.el.style.top = y + 'px';
        }
    }

    // --- INPUT ---
    const boardEl = document.getElementById('game-board');
    boardEl.addEventListener('pointerdown', e => {
        if(isProcessing || isPaused) return;
        const el = e.target.closest('.tile');
        if(!el) return;
        
        const r = parseInt(getTileDataAttr(el).r);
        const c = parseInt(getTileDataAttr(el).c);
        if(board[r][c].type === 'gem') {
            dragStart = { r, c, x: e.clientX, y: e.clientY };
            playSound('tap');
        }
    });

    boardEl.addEventListener('pointermove', e => {
        if(!dragStart) return;
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        
        if(Math.abs(dx) > 30 || Math.abs(dy) > 30) {
            const dir = Math.abs(dx) > Math.abs(dy) 
                ? (dx > 0 ? 'right' : 'left') 
                : (dy > 0 ? 'down' : 'up');
            attemptMove(dragStart.r, dragStart.c, dir);
            dragStart = null;
        }
    });

    boardEl.addEventListener('pointerup', () => {
        if(dragStart) {
            // Check double tap logic for bonuses if needed
            dragStart = null;
        }
    });

    function getTileDataAttr(el) {
        // Find tile in board array by comparing element
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(board[r][c] && board[r][c].el === el) return {r, c};
            }
        }
        return {r:-1, c:-1};
    }

    async function attemptMove(r, c, dir) {
        let nr = r, nc = c;
        if(dir === 'left') nc--;
        if(dir === 'right') nc++;
        if(dir === 'up') nr--;
        if(dir === 'down') nr++;

        if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;
        
        const t1 = board[r][c];
        const t2 = board[nr][nc];

        if(!t2 || t2.type === 'unmovable') {
            shakeTile(t1);
            return;
        }

        isProcessing = true;
        
        // Swap
        await swapTiles(t1, t2);
        
        // Check Matches
        const matchResult = findMatches();
        // Check Bonuses interaction (e.g. Bomb + Rocket) - simplified logic: always check match
        
        if(matchResult.length > 0 || (t1.bonus || t2.bonus)) {
            movesCount++; totalMoves++;
            updateUI();
            
            // If bonus involved, trigger it immediately
            if(t1.bonus || t2.bonus) {
                 await resolveMatches();
            } else {
                 await resolveMatches();
            }
            
            // Check Rise
            const threshold = gameMode === 'classic' ? 5 : 3;
            if(totalMoves % threshold === 0) {
                await riseBoard();
            }
        } else {
            // Revert
            await swapTiles(t1, t2);
            shakeTile(t1);
            shakeTile(t2);
        }
        
        isProcessing = false;
        checkGameOver();
    }

    function swapTiles(t1, t2) {
        // Update Array
        board[t1.r][t1.c] = t2;
        board[t2.r][t2.c] = t1;
        
        // Update Coords
        const tempR = t1.r, tempC = t1.c;
        t1.r = t2.r; t1.c = t2.c;
        t2.r = tempR; t2.c = tempC;
        
        updateTilePos(t1);
        updateTilePos(t2);
        
        return new Promise(r => setTimeout(r, 300));
    }
    
    function shakeTile(t) {
        t.el.classList.add('shake');
        setTimeout(() => t.el.classList.remove('shake'), 400);
    }

    // --- MATCH LOGIC ---
    function findMatches() {
        let matches = new Set();
        // H
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS-2; c++) {
                const t1 = board[r][c], t2 = board[r][c+1], t3 = board[r][c+2];
                if(t1 && t2 && t3 && t1.type=='gem' && t2.type=='gem' && t3.type=='gem') {
                    if(t1.subtype === t2.subtype && t2.subtype === t3.subtype) {
                        matches.add(t1); matches.add(t2); matches.add(t3);
                    }
                }
            }
        }
        // V
        for(let c=0; c<COLS; c++) {
            for(let r=0; r<ROWS-2; r++) {
                const t1 = board[r][c], t2 = board[r+1][c], t3 = board[r+2][c];
                if(t1 && t2 && t3 && t1.type=='gem' && t2.type=='gem' && t3.type=='gem') {
                    if(t1.subtype === t2.subtype && t2.subtype === t3.subtype) {
                        matches.add(t1); matches.add(t2); matches.add(t3);
                    }
                }
            }
        }
        return Array.from(matches);
    }

    async function resolveMatches(silent=false) {
        let matches = findMatches();
        
        while(matches.length > 0) {
            if(!silent) playSound('match');
            score += matches.length * 10;
            updateUI();

            // Animate Destruction
            const promises = matches.map(t => {
                t.el.classList.add('match');
                return new Promise(r => setTimeout(r, 300));
            });
            await Promise.all(promises);

            // Remove from DOM and Logic
            matches.forEach(t => {
                t.el.remove();
                board[t.r][t.c] = null;
            });

            // Drop
            await dropAndRefill(silent);
            
            // Re-check
            matches = findMatches();
        }
    }

    async function dropAndRefill(silent) {
        let moved = false;
        
        // 1. Drop existing
        for(let c=0; c<COLS; c++) {
            for(let r=ROWS-2; r>=0; r--) { // Start from above bottom
                if(board[r][c] && board[r][c].type !== 'unmovable') {
                    let dest = r;
                    while(dest+1 < ROWS && board[dest+1][c] === null) {
                        dest++;
                    }
                    if(dest !== r) {
                        const tile = board[r][c];
                        board[r][c] = null;
                        board[dest][c] = tile;
                        tile.r = dest;
                        updateTilePos(tile);
                        moved = true;
                    }
                }
            }
        }
        
        if(moved && !silent) await new Promise(r => setTimeout(r, 300));

        // 2. Refill from top
        const newTiles = [];
        for(let c=0; c<COLS; c++) {
            for(let r=0; r<ROWS; r++) {
                if(board[r][c] === null) {
                    // Safety check: Don't spawn if below is unmovable? 
                    // No, unmovable is occupied, so board[r][c] wouldn't be null if unmovable was there.
                    // But if unmovable is at r+1, we stop at r.
                    
                    const tile = createTile(r, c, 'gem', getRandomColor());
                    // Start position above screen
                    tile.el.style.transition = 'none';
                    tile.el.style.top = `-${TILE_SIZE}px`;
                    
                    // Force reflow
                    tile.el.offsetHeight;
                    
                    // Animate to proper pos
                    newTiles.push(tile);
                }
            }
        }
        
        if(newTiles.length > 0) {
             requestAnimationFrame(() => {
                 newTiles.forEach(t => updateTilePos(t));
             });
             if(!silent) await new Promise(r => setTimeout(r, 350));
        }
    }

    // --- RISE MECHANIC (CRITICAL FIX) ---
    async function riseBoard() {
        isProcessing = true;
        
        // 1. Check Game Over before animating (if top row has stones)
        for(let c=0; c<COLS; c++) {
            if(board[0][c] && board[0][c].type === 'unmovable') {
                gameOver();
                return;
            }
        }

        // 2. Destroy Top Row
        for(let c=0; c<COLS; c++) {
            if(board[0][c]) {
                board[0][c].el.remove();
            }
        }
        
        // 3. Shift Logic Up
        for(let r=1; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                board[r-1][c] = board[r][c];
                if(board[r-1][c]) board[r-1][c].r = r-1;
            }
        }
        
        // 4. Create New Bottom Row (Logic)
        // IMPORTANT: Mark it occupied IMMEDIATELY so drop logic doesn't put gems here
        for(let c=0; c<COLS; c++) {
            board[ROWS-1][c] = { type: 'placeholder' }; // Temporary placeholder logic check
        }
        
        // 5. Animate Move Up
        for(let r=0; r<ROWS-1; r++) {
            for(let c=0; c<COLS; c++) {
                updateTilePos(board[r][c]);
            }
        }
        
        // 6. Spawn Visual Stones at Bottom
        for(let c=0; c<COLS; c++) {
            const tile = createTile(ROWS-1, c, 'unmovable');
            // Animate entrance from bottom
            tile.el.style.transition = 'none';
            tile.el.style.top = `${(ROWS) * (TILE_SIZE + GAP)}px`;
            // Trigger reflow
            tile.el.offsetHeight;
            updateTilePos(tile); // Animate to r=9
        }

        await new Promise(r => setTimeout(r, 400));
        
        // Refill logic handles empty spots created by shift (though typically shift fills space)
        // But if we had empty spots, we need to fill them.
        // Wait, shifting up preserves holes. dropAndRefill needs to run.
        await dropAndRefill(false);
        
        isProcessing = false;
        checkGameOver();
    }

    function checkGameOver() {
        // Simple check: is top row unmovable?
        for(let c=0; c<COLS; c++) {
            if(board[0][c] && board[0][c].type === 'unmovable') {
                gameOver();
                return;
            }
        }
    }

    function gameOver() {
        playSound('lose');
        if(score > stats[gameMode].score) stats[gameMode].score = score;
        saveData();
        
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-modal').classList.add('active');
    }

    // --- UI HELPERS ---
    function getRandomColor() { return ['gem-red','gem-blue','gem-green','gem-yellow','gem-purple','gem-orange'][Math.floor(Math.random()*6)]; }
    
    function updateUI() {
        document.getElementById('score').innerText = score;
        document.getElementById('moves-count').innerText = totalMoves;
        const threshold = gameMode === 'classic' ? 5 : 3;
        const prog = (totalMoves % threshold) / threshold * 100;
        document.getElementById('rise-progress-bar').style.width = prog + '%';
    }

    // --- BUTTONS EVENTS ---
    document.getElementById('classic-mode-btn').onclick = () => startGame('classic');
    document.getElementById('hard-mode-btn').onclick = () => startGame('hard');
    
    document.getElementById('settings-btn').onclick = () => document.getElementById('settings-modal').classList.add('active');
    document.getElementById('close-settings-btn').onclick = () => document.getElementById('settings-modal').classList.remove('active');
    
    document.getElementById('rules-btn').onclick = () => document.getElementById('rules-modal').classList.add('active');
    document.getElementById('close-rules-btn').onclick = () => document.getElementById('rules-modal').classList.remove('active');
    
    document.getElementById('stats-btn').onclick = () => {
        document.getElementById('stats-modal').classList.add('active');
        document.getElementById('stats-content').innerHTML = `
            <p>Классика: ${stats.classic.score}</p>
            <p>Хард: ${stats.hard.score}</p>
        `;
    };
    document.getElementById('close-stats-btn').onclick = () => document.getElementById('stats-modal').classList.remove('active');

    // Pause
    document.getElementById('pause-btn').onclick = () => { isPaused = true; document.getElementById('pause-modal').classList.add('active'); };
    document.getElementById('resume-btn').onclick = () => { isPaused = false; document.getElementById('pause-modal').classList.remove('active'); };
    document.getElementById('restart-game-btn').onclick = () => { document.getElementById('pause-modal').classList.remove('active'); startGame(gameMode); };
    document.getElementById('main-menu-btn-pause').onclick = () => window.location.reload(); 
    
    document.getElementById('restart-over-btn').onclick = () => { document.getElementById('game-over-modal').classList.remove('active'); startGame(gameMode); };
    document.getElementById('menu-over-btn').onclick = () => window.location.reload();

    // Toggle Logic (Inverted fixed: Checked = ON)
    const sToggle = document.getElementById('mute-toggle');
    const mToggle = document.getElementById('mute-music-toggle');
    
    function updateSettingsUI() {
        sToggle.checked = isSoundOn;
        mToggle.checked = isMusicOn;
    }
    
    sToggle.onchange = () => {
        isSoundOn = sToggle.checked;
        saveData();
    };
    mToggle.onchange = () => {
        isMusicOn = mToggle.checked;
        if(isMusicOn) playMusic(); else stopMusic();
        saveData();
    };

    // Theme Logic
    document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.onclick = () => applyTheme(btn.dataset.theme);
    });
    
    function applyTheme(t) {
        currentTheme = t;
        document.body.className = t;
        document.querySelector('.main-container').style.backgroundImage = `url('bg-${t.replace('theme-','')}.png')`;
        saveData();
    }
    
    function updateThemeUI() {
        applyTheme(currentTheme);
    }
    
    </script>
</body>
</html>